plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree <- edit(plottwotree)
plottwotree()
?plot
plottwotree <- edit(plottwotree)
plottwotree()
plottwotree <- edit(plottwotree)
plottwotree()
plottwotree()
plotcorr <- edit(plotcorr)
plottwocorr <- edit(plottwocorr)
plottwocorr()
plottwocorr <- edit(plottwocorr)
plottwocorr()
plottwocorr <- edit(plottwocorr)
plottwocorr()
plottwocorr()
plottwocorr <- edit(plottwocorr)
plottwocorr()
plottwocorr()
plottwocorr()
plottwocorr()
plottwocorr()
plottwocorr()
plottwocorr()
plottwocorr()
plottwocorr()
plottwocorr()
plottwocorr()
plottwocorr()
plottwocorr()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwocorr
plottwotree
plottwotree
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
plottwotree()
?plot
?plot.default
?plot
?title
plottwotree()
plottwotree <- edit(plottwotree)
plottwotree()
plottwotree()
plottwotree <- edit(plottwotree)
?title
plottwotree <- edit(plottwotree)
plottwotree()
plottwotree()
Q()
q()
ls()
plotbrownianup()
plotbrownianup()
?plot
plotbrownianup <- edit(plotbrownianup)
plotbrownianup()
plotbrownianup()
plotbrownianup()
plotbrownianup()
plotbrownianup()
plotbrownianup()
plotbrownianup()
plotbrownianup()
ls()
plottwotree <- edit(plottwotree)
plottwotree()
plottwotree()
plottwocorr <- edit(plottwocorr)
plottwocorr()
plottwocorr()
plottwocorr()
?text
plotbrownianup <- edit(plotbrownianup)
?text
plotbrownianup <- edit(plotbrownianup)
plotbrownianup <- edit()
plotbrownianup()
plotbrownianup()
plotbrownianup()
plotbrownianup <- edit(plotbrownianup)
plotbrownianup()
?text
plotbrownianup <- edit(plotbrownianup)
plotbrownianup()
plotbrownianup()
plotbrownianup()
plotbrownianup <- edit(plotbrownianup)
plotbrownianup()
plotbrownianup()
plottwotree()
plottwotree()
plottwotree()
plottwocorr()
plottwocorr<-edit(plottwocorr)
plottwocorr()
plottwocorr()
plottwocorr<-edit(plottwocorr)
plottwocorr()
q()
ls()
plotbrownianup
plottwocorr
plottwocorr <- edit(plottwocorr)
plottwocorr(0.8)
plottwocorr(0.3)
plottwotree <- edit(plottwotree)
plottwotree <- edit()
plottwotree <- edit()
plottwotree(0.60
plottwotree(0.6)
plottwotree(0.6)
plottwotree(0.6)
plottwotree(0.6)
plottwotree(0.6)
plottwotree(0.6)
plottwotree(0.6)
plottwotree(0.6)
plottwotree(0.6)
plottwotree <- edit(plottwotree)
plottwotree(0.3)
plottwotree(0.3)
plottwotree(0.3)
plottwotree(0.3)
plottwotree(0.3)
plottwotree(0.3)
plottwotree(0.3)
plottwotree(0.3)
plottwotree(0.3)
ls()
plotbrownianup
plottwotree
plottwocorr
q()
q()
procrustes <- function(a) {
## JF: function doing Fred's Procrustes algorithm on a file of  n  rows which
##    has a name and then   m   coordinates, blank-separated.
##    argument   a   is the array  n x m  with the data
##
##   Procrustes from scratch (for two-dimensional data)
##      this version takes advantage of complex arithmetic
##      code is in Splus, very easy to convert to R
## JF:  get the dimensions
  n <- dim(b)[1];
  m <- dim(b)[2];
## JF: the code after this point is Fred's except generalized to  n x m
 
## convert to complex numbers
 vil.complex.144<-complex(r=vil.coordinate.data.144[,seq(1,n-1,2)],
                          i=vil.coordinate.data.144[,seq(2,n,2)])
## center to mean zero casewise
 vil.centered.144<-sweep(vil.complex.144,
        1,apply(vil.complex.144,1,mean),"-")
## scale to unit Centroid Size casewise
 vil.scaled.144<-sweep(vil.centered.144,
        1,sqrt(apply(Mod(vil.centered.144)^2,1,sum)),"/")
## compute tentative Procrustes mean 
 vil.testmean.144<-apply(vil.scaled.144,2,mean)
## set up GPA cycle
 vil.iterates<-matrix(vil.scaled.144,n,8)
## loop
 for (iloop in 1:5) {
## for each case
    for (j in 1:n) {
## rotate
      vil.iterates[j,]<-vil.scaled.144[j,]*
           (sum(vil.testmean.144*Conj(vil.scaled.144[j,]))/
            sum(vil.scaled.144[j,]*Conj(vil.scaled.144[j,])))
## restore Centroid Size 1
      vil.iterates[j,]<-vil.iterates[j,]/sqrt(sum(
            Mod(vil.iterates[j,])^2))
}
## convergence criterion (hardly ever needed)
  print(sum(Mod(vil.testmean.144-apply(vil.iterates,2,mean))^2))
## replace tentative mean by new centroids
   vil.testmean.144<-apply(vil.iterates,2,mean)
}
## rotate mean to first principal axis horizontal
 vil.pc1<-princomp(cbind(Re(vil.testmean.144),Im(vil.testmean.144)))$loadings[,1]
 if (vil.pc1[1]<0) vil.pc1<- -vil.pc1; vil.pc1[2]<- -vil.pc1[2]
 vil.turn<-complex(r=vil.pc1[1],i=vil.pc1[2])
 vil.testmean.144<-vil.turn*vil.testmean.144
 vil.iterates<-vil.turn*vil.iterates
##  plot
 par(mfrow=c(1,2))
 Fplotsquare(vil.testmean.144,pch=16)
 Fplotsquare(vil.iterates,pch=16)
}
ls()
procrustes
a <- read.table("fishes1.txt")
b <- data.matrix(a[,2:])
b <- data.matrix(a[,2:dim(a)[2]])
dim(b)
procrustes(b)
procrustes <- edit(procrustes)
procrustes(b)
n
procrustes <- edit(procrustes)
procrustes(b)
seq(1,99,2)
procrustes <- edit(procrustes)
procrustes(b)
procrustes <- edit(procrustes)
procrustes(b)
procrustes <- edit(procrustes)
procrustes(b)
procrustes <- edit(procrustes)
procrustes <- edit(procrustes)
procrustes <- edit(procrustes)
procrustes(b)
procrustes <- edit(procrustes)
procrustes(b)
b[1:2,]
procrustes <- edit(procrustes)
procrustes(b)
procrustes
b
vil.complex.144<-complex(r=b[,seq(1,m-1,2)], i=b[,seq(2,m,2)])
m <- dim(b)[2]
vil.complex.144<-complex(r=b[,seq(1,m-1,2)], i=b[,seq(2,m,2)])
vil.complex.144
dim(vil.complex.144)
length(vil.complex.144)
procrustes
apply(vil.complex1.144,1,mean)
vil.complex.144
apply(vil.complex.144,1,mean)
?apply
?sapply
procrustes <- edit(procrustes)
?complex
?complex
complex(real=c(1,2),imaginary=c(3,4))
complex(r=c(1,2),i=c(3,4))
procrustes <- edit(procrustes)
apply(vil.complex1.144,1,mean)
procrustes <- edit(procrustes)
apply(vil.complex.144,1,mean)
q()
procrustes
procrustes <- edit(procrustes)
apply(vil.complex.144,1,mean)
vil.complex.144
procrustes <- edit(procrustes)
procrustes(b)
procrustes <- edit(procrustes)
procrustes(b)
procrustes <- edit(procrustes)
procrustes(b)
procrustes <- edit(procrustes)
procrustes(b)
q()
procrustes
procrustes <- edit(procrustes)
x <- complex(1,2)
x
real(x)
?complex
Re(x)
Im(x)
procrustes <- edit(procrustes)
procrustes(b)
procrustes <- edit(procrustes)
procrustes <- edit()
procrustes(b)
b
procrustes <- edit()
procrustes <- edit(procrustes)
?mfrow
?par
procrustes <- edit(procrustes)
procrustes(b)
procrustes <- edit(procrustes)
procrustes(b)
procrustes <- edit(procrustes)
procrustes(b)
bbb <- procrustes(b)
procrustes <- edit(procrustes)
bbb <- procrustes(b)
procrustes <- edit(procrustes)
procrustes <- edit()
bbb <- procrustes(b)
procrustes <- edit(procrustes)
bbb <- procrustes(b)
q()
bbb <- procrustes(b)
procrustes <- edit(procrustes)
bbb <- procrustes(b)
dim(bbb)
?line
?lines
?par
procrustes <- edit(procrustes)
bbb <- procrustes(b)
procrustes <- edit(procrustes)
bbb <- procrustes(b)
procrustes <- edit(procrustes)
bbb <- procrustes(b)
procrustes <- edit(procrustes)
bbb <- procrustes(b)
bbb <- procrustes(b[1:20,])
bbb <- procrustes(b[1:40,])
procrustes <- edit(procrustes)
bbb <- procrustes(b)
procrustes
q()
rm(procrustes)
procrustes <- function(b) {
## JF: function doing Fred's Procrustes algorithm on a file of  n  rows which
##    has a name and then   m   coordinates, blank-separated.
##    argument   b   is the array  n x m  with the data
##
##   Procrustes from scratch (for two-dimensional data)
##      this version takes advantage of complex arithmetic
##      code is in Splus, very easy to convert to R
## JF:  get the dimensions
  n <- dim(b)[1];   ## number of specimens
  m <- dim(b)[2];   ## number of coordinates (twice the number of landmarks)
## JF: the code after this point is Fred's except generalized by me to  n x m
 
## convert to complex numbers
 vil.complex.144<-matrix(complex(r=b[,seq(1,m-1,2)], i=b[,seq(2,m,2)]),n,m/2)
## center to mean zero casewise
 vil.centered.144<-sweep(vil.complex.144, 1,apply(vil.complex.144,1,mean),"-")
## scale to unit Centroid Size casewise
 vil.scaled.144<-sweep(vil.centered.144,
        1,sqrt(apply(Mod(vil.centered.144)^2,1,sum)),"/")
## compute tentative Procrustes mean 
 vil.testmean.144<-apply(vil.scaled.144,2,mean)
## set up GPA cycle
 vil.iterates<-matrix(vil.scaled.144,n,m)
## loop
 print("Convergence: changes in iteration cycles 1-5");
 print("------------ ------- -- --------- ------ ---");
 for (iloop in 1:5) {
## for each case
    for (j in 1:n) {
## rotate
      vil.iterates[j,]<-vil.scaled.144[j,]*
           (sum(vil.testmean.144*Conj(vil.scaled.144[j,]))/
            sum(vil.scaled.144[j,]*Conj(vil.scaled.144[j,])))
## restore Centroid Size 1
      vil.iterates[j,]<-vil.iterates[j,]/sqrt(sum(
            Mod(vil.iterates[j,])^2))
}
## convergence criterion (hardly ever needed)
  print(sum(Mod(vil.testmean.144-apply(vil.iterates,2,mean))^2))
## replace tentative mean by new centroids
   vil.testmean.144<-apply(vil.iterates,2,mean)
}
## rotate mean to first principal axis horizontal
 vil.pc1<-princomp(cbind(Re(vil.testmean.144),Im(vil.testmean.144)))$loadings[,1]
 if (vil.pc1[1]<0) vil.pc1<- -vil.pc1; vil.pc1[2]<- -vil.pc1[2]
 vil.turn<-complex(r=vil.pc1[1],i=vil.pc1[2])
 vil.testmean.144<-vil.turn*vil.testmean.144
 vil.iterates<-vil.turn*vil.iterates
## JF: my modification of Fred's plot routines using ordinary "plot" and "line"
 xmin <- min(Re(vil.iterates));   ## find min, max of each specimen's x, y's
 ymin <- min(Im(vil.iterates));
 xmax <- max(Re(vil.iterates));
 ymax <- max(Im(vil.iterates));
##  plots a single plot with the points (smaller ones if there are more)
##  with the mean form drawn with lines in red on top of them
 plot(vil.iterates,pch=16,asp=1,cex=5/sqrt(n),xlim=c(xmin,xmax),ylim=c(ymin,ymax),xlab="x",
ylab="y")
 lines(vil.testmean.144,type="l",col="red",lwd=2);
return(vil.iterates);
}
procrustes
a
b
dim(b)
bb
bbb
procrustes <- edit(procrustes)
bbb <- procrustes(b)
bbb
dim(bbb)
procrustes
q()
dim(bbb)
bbb <- procrustes(b)
procrustes <- edit(procrustes)
bbb <- procrustes(b)
procrustes <- edit(procrustes)
bbb <- procrustes(b)
procrustes <- edit(procrustes)
q()
ls()
x <- rnorm(100,sd=1)
x
y <- cumsum(x)
y
z <- rep(0,100)
z[1] = x[1]
for (i in 2:100) {z[i] = z[i-1]*0.9+x[i]}
z
t <- seq(1,100,1)
plot(t,x)
plot(t,y)
x
mean(x)
cumsum(x)
x <- rnorm(100,mean=0,sd=1)
y <- cumsum(x)
y
z[1] = x[1]
for (i in 2:100) {z[i] = z[i-1]*0.9+x[i]}
z
plot(t,x)
plot(t,y)
plot(t,z)
plot(t,y,type="l")
plot(t,z,type="l")
plot(t,y,type="l")
plot(t,y,type="l",ylim=c(-10,10))
plot(t,y,type="l",ylim=c(-10,10))
lines(t,z,type="l",color="red",ylim=c(-10,10))
lines(t,z,type="l",col="red",ylim=c(-10,10))
plot(t,y,type="l",ylim=c(-10,10))
lines(t,z,type="l",col="red",ylim=c(-10,10))
postscript("brownou.ps")
plot(t,y,type="l",ylim=c(-10,10))
lines(t,z,type="l",col="red",ylim=c(-10,10))
dev.off()
ls()
plotbrownianup
plotouup <- plotbrownianup
plotouup <- edit(plotouup)
plotouup <- edit()
plotouup <- edit(plotouup)
plotouup()
plotouup <- edit(plotouup)
plotouup()
plotouup <- edit(plotouup)
plotouup(0)
plotouup(0.01)
plotouup(0.001)
plotouup <- edit(plotouup)
plotouup(0.001)
plotouup(0.00)
plotouup(0.00)
?seed
?random
?nrand
?nrandom
?rnorm
plotouup <- edit(plotouup)
ls()
plotouup(0.002)
q()
ls()
q()
ls()
q()
